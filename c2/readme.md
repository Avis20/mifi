


# Контрольное тестирование

Типы структур

* Списки
* Очереди
    * Вектор
    * Цикл
* Стеки
* Таблицы
* Деревья


## Списки

### I

<a href="https://rextester.com/IHCWI97164" target="_blank">RUN</a>

Элемент списка имеет след. структуру

```
struct Item {
    int k;
    struct Item *next;
};
```

Задан след. массив структур

```
struct Item a[5] = {{12, a + 3}, {25, NULL}, {38, a + 2}, {47, a + 4}, {20, a + 1}};
```

Что получиться в результате выполнения след. фрагмента

```
struct Item *ptr = a;
int n = 3;
while(n-- > 0){
    ptr = ptr->next;
}
printf("%d\n", ptr->k);
```

Ответы:
1. 12
2. 25
3. 38
4. Ошибка времени выполнения
5. 47
6. 20

Ответ: 25

## Очередь

### Очередь представленная вектором

<a href="https://rextester.com/LXXMQN56540" target="_blank">RUN</a>

Очередь представленная вектором, задана след. образом

```
int Q[] = {10, 12, 23, 38, 43, 58};
```

Определены указатели на начало очереди `pb` и конец `pe`
```
int pb = 5, pe = 3;
```

Определены операции с очередью

```
int put(int el); - запись в очередь значения el
int get(int *pel); - чтение из очереди значения в области памяти по указателю pel
```

Как измениться состояние очереди, значения указателя на начало и конец очереди и переменной `el` после выполнения след. фрагмента

```
int el;
get(&el);
put(3);
put(13);
```

Ответы:

1. Q[] = {3, 13, 23, 38, 43, 58}, pb = 2, pe = 2, el = 12
2. Q[] = {3, 12, 23, 38, 43, 58}, pb = 2, pe = 1, el = 12
3. Q[] = {3, 12, 23, 38, 43, 58}, pb = 1, pe = 1, el = 13
4. Q[] = {13, 12, 23, 38, 43, 58}, pb = 1, pe = 2, el = 3
5. Q[] = {3, 0, 23, 38, 43, 58}, pb = 2, pe = 2, el = 12
6. Правильного ответа нет

Ответ: ХЗ

---

```
Int Q[] = { 10, 12, 23, 38, 43, 58 };
Int pb=1, pe=0;
```

```
Int el;
put(13);
get(&el);
get(&el);
```
Ответ:

```
Q[] = { 13, 12, 23, 38, 43, 58 }, pb = 3, pe = 1, el = 23
```

---

```
Int pb = 5, pe =0;
Int el;
get(&el);
put(3);
get(&el);
```

Ответ:
```
Q[] = {3, 12, 23, 38, 43, 58}, pb = 1, pe = 1, el = 3
```

### Очередь представленная циклическим списком

Элемент очереди, представленной циклическим списком, имеет след. структуру

```
struct Item {
    int val;
    struct Item *next;
};
```

Определен указатель очереди

```
struct Item *ptr;
```
Определены след. операции с очередью

```
int put(struct Item el); - запись в очередь значения el
int get(int *pel); - чтение из очереди значения в области памяти по указателю pel
```
Как измениться состояние очереди, значения указателя на начало и конец очереди и переменной `el` после выполнения след. фрагмента

Текущее состояние очереди задани след. последовательностью эл.

#### 1

```
Q1(12)--->Q2(23)--->Q3(38)--->Q4(43)--->Q5(58)--->Q1
ptr--->Q3
```

```
int el;
struct Item N1 = {3, NULL};
get(&el);
get(&el);
put(N1);
```

Ответ
```
Q1(12)--->Q2(23)--->Q3(38)--->N1(3)--->Q1, ptr--->N1, el = 58
```

#### 2

```
Q1(12)--->Q1(23)--->Q1(38)--->Q1(43)--->Q1(58)--->Q1
ptr--->Q1
```

```
struct Item N1 = { 3, NULL }, N2 = {13, NULL };
put(N1);
get(&el);
put(N2);
```

Ответ
```
Q1(12)--->N1(3)--->N2(13)--->Q3(38)--->Q4(43)--->Q5(58)--->Q1, ptr--->N2, el = 58
```

#### 3

```
Q1(12) --- > Q2(23) --- > Q3(38) --- > Q4(43) --- > Q5(58) --- > Q1,
ptr --- > Q3
```

```
int el;
struct Item N1 = { 3, NULL };
get(&el);
put(N1);
get(&el);
```



## Таблицы

### Просматриваемая таблица

Дана просматриваемая таблица, представленная вектором. Элемент таблицы имеет следующую структуру:

```
struct info {
    int rel;
    char *info;
    struct info *next;
}
```

```
struct item {
    int key;
    char *info;
}
```

Таблица задана следующим образом:
```
struct Item table[SIZE]; // SIZE – некоторая ранее определенная константа, задающая размер вектора
int n; //текущий размер таблицы
```

В таблице могут находиться элементы с одинаковыми ключами; для таких элементов
автоматически формируется номер версии (если элемент с некоторым ключом появляется первый
раз, его номер версии равен 1, для каждого следующего появление данного ключа его последний
номер версии увеличивается на 1).

для таблицы определенны следующие операции:

```
int findLastRel(int key); - найти в таблице последнюю версию элемента, заданного ключом;
```

```
int insert(int key, char *info); - включить элемент в таблицу; данная функция использует findLastRel()
```

```
int del(int key, int rel); - удалить из таблицы указанную версию элемента, заданного ключом;
```

В указанных функциях используется глобальная переменная

```
int used; - используется для определения количества просмотренных функцией элементов таблицы и (для функции del() ) количества переменных элементов таблицы.
```

Указать, что будет выведено в поток при выполнении следующего фрагмента программы для
таблицы, приведенной на рисунке.


---


Дана просматриваемая таблица, представленная вектором. Элемент таблицы имеет
следующую структуру:

```
struct Item {
    int busy;
    int key;
    char *info;
};
```

Таблица задана следующим образом:
```
struct Item table[SIZE]; // SIZE – некоторая ранее определенная константа, задающая размер вектора
int n; //текущий размер таблицы
```
В таблице не могут находиться элементы с одинаковыми ключами;



В указанных функциях используется глобальные переменные:
```
int compare; - используется в функции find() для определения количества просмотренных функцией элементов таблицы.

int move; - используется в функциях для сборки мусора, insert() и del() для определения количества перемещенных в функциях элементов таблицы.
```

Указать, что будет выведено в поток при выполнении следующего фрагмента программы для
таблицы, приведенной на рисунке.

```
int k1 = 0, k2 = 0;
insert(21, “str1”);
k1+ = compare, k2+ = move;
insert(10, “str2”);
k1+ = compare, k2+ = move;
printf(“n = %d, compare = %d, move = %d\n”, n, k1, k2);
```


|busy|key|info|
|---|---|---|
|0|12|NULL|
|1|3|...|
|0|21|NULL|
|1|43|...|
|1|15|...|
|0|8|NULL|
|0|3|NULL|


```
size = 7
n = 6
```

Ответ:
```
n = 5, Compare = 13, move = 4
```